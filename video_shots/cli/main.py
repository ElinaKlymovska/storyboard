"""Unified CLI interface for video analysis."""

import argparse
import sys
from pathlib import Path
from typing import Optional

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from video_shots.analysis.unified_analyzer import UnifiedAnalyzer
from video_shots.config.analysis_config import load_config, create_default_config_file
from video_shots.logging.logger import setup_logging


def create_parser() -> argparse.ArgumentParser:
    """Create command line argument parser."""
    parser = argparse.ArgumentParser(
        description="Unified Video Analysis Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Analyze a video with default settings
  python -m video_shots.cli.main analyze input/videos/video.mp4
  
  # Analyze with custom output directory
  python -m video_shots.cli.main analyze input/videos/video.mp4 -o output/my_analysis
  
  # Analyze with custom configuration
  python -m video_shots.cli.main analyze input/videos/video.mp4 -c config/custom.json
  
  # Split video into 0.5 second segments with audio
  python -m video_shots.cli.main segment input/videos/video.mp4
  
  # Split video into 2 second segments with custom output
  python -m video_shots.cli.main segment input/videos/video.mp4 -d 2.0 -o output/segments
  
  # Create default configuration file
  python -m video_shots.cli.main create-config -o config/default.json
  
  # Set log level to debug
  python -m video_shots.cli.main analyze input/videos/video.mp4 --log-level DEBUG
        """
    )
    
    # Global arguments
    parser.add_argument(
        "--log-level",
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        default="INFO",
        help="Set logging level (default: INFO)"
    )
    
    parser.add_argument(
        "--config", "-c",
        type=str,
        help="Path to configuration file (JSON format)"
    )
    
    # Subcommands
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # Analyze command
    analyze_parser = subparsers.add_parser(
        "analyze",
        help="Analyze a video file",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="Perform complete video analysis including audio and visual components."
    )
    
    analyze_parser.add_argument(
        "video_path",
        type=str,
        help="Path to the video file to analyze"
    )
    
    analyze_parser.add_argument(
        "--output", "-o",
        type=str,
        help="Output directory for results (default: auto-generated)"
    )
    
    analyze_parser.add_argument(
        "--audio-only",
        action="store_true",
        help="Perform only audio analysis"
    )
    
    analyze_parser.add_argument(
        "--video-only", 
        action="store_true",
        help="Perform only video analysis"
    )
    
    analyze_parser.add_argument(
        "--no-transcription",
        action="store_true",
        help="Skip audio transcription"
    )
    
    analyze_parser.add_argument(
        "--keyframe-mode",
        choices=["interval_based", "event_driven"],
        help="Keyframe selection mode"
    )
    
    analyze_parser.add_argument(
        "--keyframe-interval",
        type=float,
        help="Interval between keyframes in seconds (for interval_based mode)"
    )
    
    analyze_parser.add_argument(
        "--max-keyframes",
        type=int,
        help="Maximum number of keyframes to extract"
    )
    
    # Create config command
    config_parser = subparsers.add_parser(
        "create-config",
        help="Create a default configuration file",
        description="Generate a default configuration file that can be customized."
    )
    
    config_parser.add_argument(
        "--output", "-o",
        type=str,
        default="config/default_config.json",
        help="Output path for configuration file (default: config/default_config.json)"
    )
    
    # Info command
    info_parser = subparsers.add_parser(
        "info",
        help="Show information about a video file",
        description="Display basic information about a video file without full analysis."
    )
    
    info_parser.add_argument(
        "video_path",
        type=str,
        help="Path to the video file"
    )
    
    # Sessions command
    sessions_parser = subparsers.add_parser(
        "sessions",
        help="Manage analysis sessions",
        description="View and manage analysis sessions and output data."
    )
    
    sessions_subparsers = sessions_parser.add_subparsers(dest="sessions_action", help="Session actions")
    
    # List sessions
    list_parser = sessions_subparsers.add_parser("list", help="List recent sessions")
    list_parser.add_argument("--limit", "-l", type=int, default=10, help="Number of sessions to show")
    
    # Session info
    info_sessions_parser = sessions_subparsers.add_parser("info", help="Show session information")
    info_sessions_parser.add_argument("session_id", help="Session ID or partial session ID")
    
    # Archive old sessions
    archive_parser = sessions_subparsers.add_parser("archive", help="Archive old sessions")
    archive_parser.add_argument("--days", "-d", type=int, default=30, help="Archive sessions older than X days")
    
    # Clean up sessions
    cleanup_parser = sessions_subparsers.add_parser("cleanup", help="Clean up temp files in all sessions")
    
    # Segment command
    segment_parser = subparsers.add_parser(
        "segment",
        help="Split video into segments with audio",
        description="Split a video file into smaller segments while preserving audio."
    )
    
    segment_parser.add_argument(
        "video_path",
        type=str,
        help="Path to the video file to segment"
    )
    
    segment_parser.add_argument(
        "--output", "-o",
        type=str,
        help="Output directory for segments (default: auto-generated based on video name)"
    )
    
    segment_parser.add_argument(
        "--duration", "-d",
        type=float,
        default=0.5,
        help="Duration of each segment in seconds (default: 0.5)"
    )
    
    segment_parser.add_argument(
        "--prefix", "-p",
        type=str,
        default="segment",
        help="Prefix for segment filenames (default: segment)"
    )
    
    segment_parser.add_argument(
        "--max-segments", "-m",
        type=int,
        help="Maximum number of segments to create (default: unlimited)"
    )
    
    return parser


def handle_analyze_command(args, config) -> int:
    """Handle the analyze command."""
    from video_shots.logging.logger import get_logger
    
    logger = get_logger()
    video_path = Path(args.video_path)
    
    if not video_path.exists():
        logger.error(f"Video file not found: {video_path}")
        return 1
    
    # Update config based on command line arguments
    if args.no_transcription:
        config.audio.enable_transcription = False
    
    if args.keyframe_mode:
        config.video.keyframe_selection_mode = args.keyframe_mode
    
    if args.keyframe_interval:
        config.video.keyframe_interval = args.keyframe_interval
    
    if args.max_keyframes:
        config.video.max_keyframes = args.max_keyframes
    
    # Set output directory
    output_dir = None
    if args.output:
        output_dir = Path(args.output)
    
    try:
        # Create analyzer
        analyzer = UnifiedAnalyzer(config)
        
        # Perform analysis
        if args.audio_only:
            logger.info("üéµ Performing audio-only analysis...")
            audio_result = analyzer.audio_analyzer.analyze_video_audio(video_path, output_dir)
            if audio_result.success:
                logger.info("‚úÖ Audio analysis completed successfully!")
                logger.info(f"üìä Results: {len(audio_result.audio_segments)} audio segments, "
                           f"{len(audio_result.transcript_segments)} speech segments")
            else:
                logger.error(f"‚ùå Audio analysis failed: {audio_result.error_message}")
                return 1
                
        elif args.video_only:
            logger.info("üé¨ Performing video-only analysis...")
            video_result = analyzer.video_analyzer.analyze_video(video_path, output_dir)
            if video_result.success:
                logger.info("‚úÖ Video analysis completed successfully!")
                logger.info(f"üìä Results: {len(video_result.keyframes)} keyframes, "
                           f"{len(video_result.shots)} shots")
            else:
                logger.error(f"‚ùå Video analysis failed: {video_result.error_message}")
                return 1
        else:
            logger.info("üé¨üéµ Performing complete analysis...")
            result = analyzer.analyze_complete_video(video_path, output_dir)
            
            if result.success:
                logger.info("‚úÖ Complete analysis finished successfully!")
                logger.info(f"üìä Summary:")
                logger.info(f"   - Duration: {result.audio_result.duration:.1f}s")
                logger.info(f"   - Keyframes: {result.total_keyframes}")
                logger.info(f"   - Audio segments: {result.total_audio_segments}")
                logger.info(f"   - Speech segments: {result.total_speech_segments}")
                logger.info(f"   - Output directory: {result.output_dir}")
                logger.info(f"   - Content type: {result.content_analysis.get('content_type', 'Unknown')}")
                logger.info(f"   - Overall quality score: {result.technical_quality.get('overall_score', 0)}/100")
            else:
                logger.error(f"‚ùå Analysis failed: {result.error_message}")
                return 1
        
        return 0
        
    except Exception as e:
        logger.error(f"‚ùå Unexpected error during analysis: {e}")
        return 1


def handle_create_config_command(args) -> int:
    """Handle the create-config command."""
    from video_shots.logging.logger import get_logger
    
    logger = get_logger()
    output_path = Path(args.output)
    
    try:
        create_default_config_file(output_path)
        logger.info(f"‚úÖ Default configuration created: {output_path}")
        return 0
    except Exception as e:
        logger.error(f"‚ùå Failed to create configuration: {e}")
        return 1


def handle_info_command(args) -> int:
    """Handle the info command."""
    from video_shots.logging.logger import get_logger
    from video_shots.analysis.unified_video_analyzer import UnifiedVideoAnalyzer
    
    logger = get_logger()
    video_path = Path(args.video_path)
    
    if not video_path.exists():
        logger.error(f"Video file not found: {video_path}")
        return 1
    
    try:
        analyzer = UnifiedVideoAnalyzer()
        metadata = analyzer._extract_metadata(video_path)
        
        print(f"\nüìπ Video Information: {video_path.name}")
        print("=" * 50)
        print(f"Duration: {metadata.duration:.1f} seconds")
        print(f"FPS: {metadata.fps:.1f}")
        print(f"Resolution: {metadata.resolution[0]}x{metadata.resolution[1]}")
        print(f"Aspect Ratio: {metadata.aspect_ratio}")
        print(f"Format: {metadata.format}")
        print(f"Total Frames: {metadata.frame_count}")
        print(f"File Size: {video_path.stat().st_size / (1024*1024):.1f} MB")
        
        return 0
        
    except Exception as e:
        logger.error(f"‚ùå Failed to get video info: {e}")
        return 1


def handle_sessions_command(args) -> int:
    """Handle the sessions command."""
    from video_shots.logging.logger import get_logger
    from video_shots.utils.output_manager import get_output_manager
    
    logger = get_logger()
    manager = get_output_manager()
    
    if args.sessions_action == "list":
        # List recent sessions
        sessions = manager.get_recent_sessions(args.limit)
        
        if not sessions:
            print("üìÅ –ù–µ–º–∞—î –∑–±–µ—Ä–µ–∂–µ–Ω–∏—Ö —Å–µ—Å—ñ–π –∞–Ω–∞–ª—ñ–∑—É")
            return 0
            
        print(f"üìã –û—Å—Ç–∞–Ω–Ω—ñ {len(sessions)} —Å–µ—Å—ñ–π –∞–Ω–∞–ª—ñ–∑—É:")
        print("=" * 80)
        
        for i, session_dir in enumerate(sessions, 1):
            # Try to load session metadata
            metadata_file = session_dir / "session_metadata.json"
            if metadata_file.exists():
                try:
                    import json
                    with open(metadata_file, 'r', encoding='utf-8') as f:
                        metadata = json.load(f)
                    
                    session_id = metadata.get('session_id', 'unknown')
                    video_name = metadata.get('video_name', 'unknown')
                    start_time = metadata.get('start_time', 'unknown')
                    success = metadata.get('success', False)
                    analysis_type = metadata.get('analysis_type', 'unknown')
                    
                    status = "‚úÖ –£—Å–ø—ñ—à–Ω–æ" if success else "‚ùå –ü–æ–º–∏–ª–∫–∞"
                    
                    print(f"{i:2}. {session_dir.name}")
                    print(f"    üìΩÔ∏è  –í—ñ–¥–µ–æ: {video_name}")
                    print(f"    üÜî ID: {session_id}")
                    print(f"    üîç –¢–∏–ø: {analysis_type}")
                    print(f"    üìÖ –ß–∞—Å: {start_time}")
                    print(f"    üìä –°—Ç–∞—Ç—É—Å: {status}")
                    print()
                    
                except Exception as e:
                    print(f"{i:2}. {session_dir.name} (–º–µ—Ç–∞–¥–∞–Ω—ñ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ñ)")
                    print()
            else:
                print(f"{i:2}. {session_dir.name} (–±–µ–∑ –º–µ—Ç–∞–¥–∞–Ω–∏—Ö)")
                print()
                
    elif args.sessions_action == "info":
        # Show detailed session info
        sessions = manager.get_recent_sessions(100)  # Get more sessions to search
        
        # Find session by ID (partial match)
        target_session = None
        for session_dir in sessions:
            if args.session_id.lower() in session_dir.name.lower():
                target_session = session_dir
                break
                
        if not target_session:
            logger.error(f"‚ùå –°–µ—Å—ñ—é –∑ ID '{args.session_id}' –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ")
            return 1
            
        # Load and display session info
        metadata_file = target_session / "session_metadata.json"
        if metadata_file.exists():
            try:
                import json
                with open(metadata_file, 'r', encoding='utf-8') as f:
                    metadata = json.load(f)
                    
                print(f"üìã –Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ —Å–µ—Å—ñ—é: {target_session.name}")
                print("=" * 80)
                print(f"üÜî ID —Å–µ—Å—ñ—ó: {metadata.get('session_id', 'unknown')}")
                print(f"üìΩÔ∏è –í—ñ–¥–µ–æ: {metadata.get('video_name', 'unknown')}")
                print(f"üìÅ –®–ª—è—Ö –¥–æ –≤—ñ–¥–µ–æ: {metadata.get('video_path', 'unknown')}")
                print(f"üîç –¢–∏–ø –∞–Ω–∞–ª—ñ–∑—É: {metadata.get('analysis_type', 'unknown')}")
                print(f"üìÖ –ü–æ—á–∞—Ç–æ–∫: {metadata.get('start_time', 'unknown')}")
                print(f"‚è∞ –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—è: {metadata.get('end_time', '–≤ –ø—Ä–æ—Ü–µ—Å—ñ')}")
                print(f"üìä –°—Ç–∞—Ç—É—Å: {'‚úÖ –£—Å–ø—ñ—à–Ω–æ' if metadata.get('success', False) else '‚ùå –ü–æ–º–∏–ª–∫–∞'}")
                print(f"‚è±Ô∏è –¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å –≤—ñ–¥–µ–æ: {metadata.get('total_duration', '–Ω–µ–≤—ñ–¥–æ–º–æ')} —Å–µ–∫")
                print(f"üñºÔ∏è –ö–ª—é—á–æ–≤—ñ –∫–∞–¥—Ä–∏: {metadata.get('keyframes_count', 0)}")
                print(f"üéµ –ê—É–¥—ñ–æ —Å–µ–≥–º–µ–Ω—Ç–∏: {metadata.get('audio_segments_count', 0)}")
                
                if metadata.get('error_message'):
                    print(f"‚ùå –ü–æ–º–∏–ª–∫–∞: {metadata['error_message']}")
                    
                print(f"üìÅ –î–∏—Ä–µ–∫—Ç–æ—Ä—ñ—è: {target_session}")
                
                # Show output files
                output_files = metadata.get('output_files', [])
                if output_files:
                    print("\nüìÑ –°—Ç–≤–æ—Ä–µ–Ω—ñ —Ñ–∞–π–ª–∏:")
                    for file_info in output_files:
                        print(f"   ‚Ä¢ {file_info}")
                        
            except Exception as e:
                logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ —á–∏—Ç–∞–Ω–Ω—è –º–µ—Ç–∞–¥–∞–Ω–∏—Ö: {e}")
                return 1
        else:
            logger.error(f"‚ùå –§–∞–π–ª –º–µ—Ç–∞–¥–∞–Ω–∏—Ö –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –¥–ª—è —Å–µ—Å—ñ—ó {target_session.name}")
            return 1
            
    elif args.sessions_action == "archive":
        # Archive old sessions
        archived_count = manager.archive_old_sessions(args.days)
        if archived_count > 0:
            print(f"üì¶ –ê—Ä—Ö—ñ–≤–æ–≤–∞–Ω–æ {archived_count} —Å–µ—Å—ñ–π —Å—Ç–∞—Ä—à–∏—Ö –∑–∞ {args.days} –¥–Ω—ñ–≤")
        else:
            print(f"üì¶ –ù–µ–º–∞—î —Å–µ—Å—ñ–π –¥–ª—è –∞—Ä—Ö—ñ–≤—É–≤–∞–Ω–Ω—è (—Å—Ç–∞—Ä—à–∏—Ö –∑–∞ {args.days} –¥–Ω—ñ–≤)")
            
    elif args.sessions_action == "cleanup":
        # Clean up temp files
        sessions = manager.get_recent_sessions(1000)  # Get all sessions
        cleaned_count = 0
        
        for session_dir in sessions:
            temp_dir = session_dir / "temp"
            if temp_dir.exists():
                import shutil
                try:
                    shutil.rmtree(temp_dir)
                    temp_dir.mkdir()
                    cleaned_count += 1
                except Exception as e:
                    logger.warning(f"–ü–æ–º–∏–ª–∫–∞ –æ—á–∏—â–µ–Ω–Ω—è {temp_dir}: {e}")
                    
        print(f"üßπ –û—á–∏—â–µ–Ω–æ —Ç–∏–º—á–∞—Å–æ–≤—ñ —Ñ–∞–π–ª–∏ –≤ {cleaned_count} —Å–µ—Å—ñ—è—Ö")
        
    else:
        print("‚ùå –ù–µ–≤—ñ–¥–æ–º–∞ –¥—ñ—è –¥–ª—è –∫–æ–º–∞–Ω–¥–∏ sessions")
        return 1
        
    return 0


def handle_segment_command(args) -> int:
    """Handle the segment command."""
    from video_shots.logging.logger import get_logger
    from video_shots.core.video_processing import split_video_with_audio
    from video_shots.utils.output_manager import get_output_manager
    
    logger = get_logger()
    video_path = Path(args.video_path)
    
    if not video_path.exists():
        logger.error(f"Video file not found: {video_path}")
        return 1
    
    # Determine output directory
    if args.output:
        output_dir = Path(args.output)
    else:
        # Create output directory based on video name
        video_stem = video_path.stem
        output_dir = Path("output") / f"{video_stem}_segments"
    
    output_dir.mkdir(parents=True, exist_ok=True)
    
    try:
        logger.info(f"üé¨ Starting video segmentation...")
        logger.info(f"üìΩÔ∏è Input: {video_path}")
        logger.info(f"‚è±Ô∏è Segment duration: {args.duration} seconds")
        logger.info(f"üìÅ Output directory: {output_dir}")
        
        # Split video with audio
        segment_paths = split_video_with_audio(
            video_path=video_path,
            output_dir=output_dir,
            segment_duration=args.duration,
            prefix=args.prefix,
            max_segments=args.max_segments
        )
        
        if segment_paths:
            logger.info(f"‚úÖ Segmentation completed successfully!")
            logger.info(f"üìä Created {len(segment_paths)} segments")
            logger.info(f"üìÅ Segments saved to: {output_dir / 'segments'}")
            
            # Show first few segments as examples
            logger.info("üìÑ Generated segments:")
            for i, path in enumerate(segment_paths[:5]):
                logger.info(f"   {i+1}. {path.name}")
            
            if len(segment_paths) > 5:
                logger.info(f"   ... and {len(segment_paths) - 5} more segments")
                
        else:
            logger.warning("‚ö†Ô∏è No segments were created")
            return 1
        
        return 0
        
    except Exception as e:
        logger.error(f"‚ùå Segmentation failed: {e}")
        return 1


def main() -> int:
    """Main CLI entry point."""
    parser = create_parser()
    args = parser.parse_args()
    
    # Setup logging
    logger = setup_logging(args.log_level)
    
    # Load configuration
    try:
        if args.config:
            config = load_config(args.config)
            logger.info(f"üìÑ Loaded configuration from: {args.config}")
        else:
            config = load_config()
            logger.debug("üìÑ Using default configuration")
    except Exception as e:
        logger.error(f"‚ùå Failed to load configuration: {e}")
        return 1
    
    # Handle commands
    if args.command == "analyze":
        return handle_analyze_command(args, config)
    elif args.command == "create-config":
        return handle_create_config_command(args)
    elif args.command == "info":
        return handle_info_command(args)
    elif args.command == "sessions":
        return handle_sessions_command(args)
    elif args.command == "segment":
        return handle_segment_command(args)
    else:
        parser.print_help()
        return 1


if __name__ == "__main__":
    sys.exit(main())